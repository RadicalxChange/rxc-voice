from rest_framework import serializers
from django.contrib.auth import authenticate
from guardian.shortcuts import assign_perm
from django.utils.translation import gettext_lazy as _
import uuid
from django.utils.http import urlsafe_base64_encode, urlsafe_base64_decode
from django.utils.encoding import force_bytes, force_text
from django.utils import timezone
from django.core.exceptions import ValidationError

from .models import Election, Vote, Proposal, Delegate, Conversation, Process, Transfer
from django.contrib.auth.models import (User, Group, Permission)


class ConversationSerializer(serializers.ModelSerializer):
    class Meta:
        model = Conversation
        fields = '__all__'

    def create(self, validated_data):
        conversation = Conversation.objects.create(
            uuid=str(uuid.uuid1()),
            title=validated_data.get('title'),
            description=validated_data.get('description'),
            start_date=validated_data.get('start_date'),
            end_date=validated_data.get('end_date'),
            )
        conversation.groups.set(validated_data.get('groups', []))
        return conversation


class VoteSerializer(serializers.ModelSerializer):
    class Meta:
        model = Vote
        fields = '__all__'

    def create(self, validated_data):
        election = Election.objects.get(pk=self.context.get("election_id"))
        sender = Delegate.objects.get(pk=validated_data['sender'].id)
        # if sender.user.has_perm('can_view_results', election):
        #     raise ValidationError("Invalid Vote: user already voted.")
        assign_perm('can_view_results', sender.user, election)

        proposal = Proposal.objects.get(pk=validated_data['proposal'].id)
        amount = int(validated_data['amount'])
        proposal.votes_received = proposal.votes_received + amount
        proposal.credits_received = proposal.credits_received + (amount * amount)
        proposal.save()
        sender.credit_balance -= amount * amount
        sender.save()

        vote = Vote.objects.create(
            sender=sender,
            proposal=validated_data['proposal'],
            amount=validated_data['amount'],
            date=validated_data['date'],
        )
        return vote


class ProposalSerializer(serializers.ModelSerializer):
    class Meta:
        model = Proposal
        fields = '__all__'


class ElectionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Election
        fields = '__all__'


class GroupSerializer(serializers.ModelSerializer):
    class Meta:
        model = Group
        fields = '__all__'


class PermissionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Permission
        fields = '__all__'


class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = '__all__'
        extra_kwargs = {
            'password': {'write_only': True},
            'username': {'required': False},
            'email': {'required': True},
            }

    def create(self, validated_data, is_autogenerated, set_unusable_password):
        """
        autogenerated user: set uuid as username.

        standard user: conceal password and set email as username.
        """
        if is_autogenerated:
            validated_data['username'] = validated_data.get('password', '')
        else:
            validated_data['username'] = validated_data.get('email', '')
        user = User(
            username=validated_data.get('username'),
            first_name=validated_data.get('first_name', ''),
            last_name=validated_data.get('last_name', ''),
            email=validated_data.get('email'),
            is_staff=validated_data.get('is_staff', False),
            is_superuser=validated_data.get('is_superuser', False),
        )
        if set_unusable_password:
            user.set_unusable_password()
        else:
            user.set_password(validated_data['password'])
        user.save()
        user.groups.set(validated_data.get('groups', []))
        return user

    def update(self, instance, validated_data):
        instance.username = validated_data.get('username', instance.username)
        instance.first_name = validated_data.get('first_name', instance.first_name)
        instance.last_name = validated_data.get('last_name', instance.last_name)
        instance.email = validated_data.get('email', instance.email)
        instance.set_password(validated_data['password'])
        instance.save()
        return instance


class DelegateSerializer(serializers.ModelSerializer):
    user = UserSerializer(required=True)

    class Meta:
        model = Delegate
        fields = '__all__'

    def create(self, validated_data, set_unusable_password):
        user_data = validated_data.get('user')
        is_autogenerated = validated_data.get('is_autogenerated', False)
        user = UserSerializer.create(
            UserSerializer(),
            validated_data=user_data,
            is_autogenerated=is_autogenerated,
            set_unusable_password=set_unusable_password)
        delegate, created = Delegate.objects.update_or_create(
            user=user,
            is_autogenerated=is_autogenerated,
            profile_pic=validated_data.get('profile_pic'),
            # phone_number=validated_data.get('phone_number', ''),
            invited_by=validated_data.get('invited_by'),
            credit_balance=validated_data.get('credit_balance', 0),
            )
        return delegate


class TransferSerializer(serializers.ModelSerializer):
    class Meta:
        model = Transfer
        fields = '__all__'
        extra_kwargs = {
            'recipient': {'write_only': True},
            'recipient_object': {'write_only': True},
            'date': {'write_only': True},
            }

    def create(self, validated_data):
        process = validated_data.get('process')
        if process.conversation.start_date < timezone.now():
            raise ValidationError("Invalid Transfer: Delegation Stage is concluded.")
        recipient = validated_data.get('recipient')
        sender = validated_data.get('sender')
        if not sender:
            raise ValidationError("Invalid sender: delegate not found.")
        if int(self.context.get('request').data['amount']) > sender.credit_balance:
            # delete recipient user if autogenerated
            raise ValidationError("Invalid amount: insufficient credits.")
        recipient_object = Delegate.objects.filter(user__email=recipient).first()
        if not recipient_object:
            recipient_object = Delegate.objects.filter(public_username=recipient).first()
        is_invitation = not recipient_object
        if is_invitation:
            new_delegate = DelegateSerializer.create(
                DelegateSerializer(),
                validated_data={
                'user': {
                    'username': recipient,
                    'email': recipient,
                },
                'credit_balance': validated_data.get('amount'),
                'invited_by': sender,
                },
                set_unusable_password=True)
            rxc_voice = Group.objects.get(name="RxC Voice")
            new_delegate.user.groups.add(rxc_voice)
            recipient_object = new_delegate
        elif recipient_object.id == sender.id or self.context.get('request').user == recipient_object:
            raise ValidationError("Invalid transfer.")
        sender.credit_balance -= validated_data.get('amount')
        sender.save()
        process.delegates.add(recipient_object)
        transfer = Transfer.objects.create(
            sender=sender,
            recipient=recipient,
            recipient_object=recipient_object,
            amount=validated_data.get('amount'),
            date=validated_data.get('date'),
            status=('P' if is_invitation else 'A'),
            process=process,
            )
        return transfer


class PrivateUserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'is_active']


class PrivateDelegateSerializer(serializers.ModelSerializer):
    user = PrivateUserSerializer(required=True)

    class Meta:
        model = Delegate
        fields = ['id', 'user', 'public_username', 'credit_balance']


class CustomAuthTokenSerializer(serializers.Serializer):
    email = serializers.EmailField(
        label=_("Email"),
        write_only=True
        )
    password = serializers.CharField(
        label=_("Password",),
        style={'input_type': 'password'},
        trim_whitespace=False,
        write_only=True
    )
    token = serializers.CharField(
        label=_("Token"),
        read_only=True
    )

    def validate(self, attrs):
        email = attrs.get('email')
        password = attrs.get('password')

        if email and password:
            user = authenticate(request=self.context.get('request'),
                                email=email, password=password)
            """
            The authenticate call simply returns None for is_active=False
            users. (Assuming the default ModelBackend authentication
            backend.)
            """
            if not user:
                msg = _('Unable to log in with provided credentials.')
                raise serializers.ValidationError(msg, code='authorization')
        else:
            msg = _('Must include "email" and "password".')
            raise serializers.ValidationError(msg, code='authorization')

        attrs['user'] = user
        return attrs


class ProcessSerializer(serializers.ModelSerializer):
    delegates = PrivateDelegateSerializer(many=True)
    conversation = ConversationSerializer()
    election = ElectionSerializer()

    class Meta:
        model = Process
        fields = '__all__'

    def create(self, validated_data):
        conversation_data = validated_data.get('conversation')
        if conversation_data is not None:
            conversation_data = ConversationSerializer.create(
                ConversationSerializer(),
                validated_data=conversation_data,
                )
        election_data = validated_data.get('election')
        if election_data is not None:
            election_data = ElectionSerializer.create(
                ElectionSerializer(),
                validated_data=election_data,
            )
        process, created = Process.objects.update_or_create(
            title=validated_data.get('title'),
            description=validated_data.get('description'),
            start_date=validated_data.get('start_date'),
            end_date=validated_data.get('end_date'),
            matching_pool=validated_data.get('matching_pool'),
            conversation=conversation_data,
            curation_info=validated_data.get('curation_info'),
            top_posts=validated_data.get('top_posts', []),
            election=election_data,
            )
        process.groups.set(validated_data.get('groups', []))
        process.delegates.set(validated_data.get('delegates', []))
        return process
